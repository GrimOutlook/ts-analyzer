#![forbid(unsafe_code)]
#![deny(future_incompatible, missing_docs, rust_2018_idioms, unused, warnings)]

//! This crate is used to read the payload data from a given transport stream. It is not intended
//! for multiplexing, demultiplexing, or streaming video. It has only been made for the purpose of
//! inspecting the transport stream packet header data and payload data.
//! 
//! # Sources
//! 
//! Almost all of the information related to parsing the packets was found on wikipedia, my lord and
//! savior. This [article](https://en.wikipedia.org/wiki/MPEG_transport_stream) in particular.
//! 
//! Please donate to wikipedia if you have the means.
// Include the README in the doc-tests.
#![doc = include_str!("../README.md")]

pub mod packet;
pub mod reader;

mod helpers {
    pub mod tracked_payload;
}

/// Flag that is set when transmitting encrypted video
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum TransportScramblingControl {
    /// `0` indicates that the data is not scrambled
    NoScrambling = 0,
    /// `1` is reserved per the standard
    Reserved = 1,
    /// `2` indicates that the data is scrambled with the/an "even" key.
    EvenKey = 2,
    /// `3` indicates that the data is scrambled with the/an "odd" key.
    OddKey = 3,
}

/// Whether the packet has a Payload, an Adaptation Field, both, or neither.
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum AdaptationFieldControl {
    /// `0` is reserved per the standard
    Reserved = 0,
    /// `1` indicates that only the payload field exists
    Payload = 1,
    /// `2` indicates that only the adaptation field exists
    AdaptationField = 2,
    /// `3` indicates that both the adaptation field and payload field exist.
    AdaptationAndPayload = 3,
}

/// Errors that can be created by this application
#[derive(Debug)]
pub enum TSError {
    /// Errors generated by reading data from a file or buffer
    ReaderError(std::io::Error),
    /// Error generated when trying to parse a TS packet with an invalid first byte.
    InvalidFirstByte(u8 /* invalid byte */),
    /// Error generated when trying to parse the payload of a TS packet and the payload pointer
    /// points past the end of the packet.
    InvalidPayloadPointer(u8 /* pointer */, u8 /* remainder */),
    /// Error generated when trying to do operations on the payload of a packet but no payload is
    /// present
    NoPayload,
    /// Error generated when no SYNC byte can be found in a reader object
    NoSyncByte,
    /// Error generated when trying to do operations on a TS packet that is expected to have a new
    /// payload in it but the `PUSI` flag isn't set.
    PUSIsNotSet,
}

impl std::error::Error for TSError {}

impl std::fmt::Display for TSError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TSError::InvalidFirstByte(invalid_byte) => 
                write!(f, "invalid first byte for packet: [{}]", invalid_byte),
            TSError::InvalidPayloadPointer(pointer, remainder) =>
                write!(f, "payload pointer [{}] is too large for packet remainder [{}]",
                    pointer, remainder),
            TSError::NoPayload => write!(f, "no payload found in packet"),
            TSError::NoSyncByte => write!(f, "no sync byte found in reader"),
            TSError::PUSIsNotSet =>
                write!(f, "payload does not contain the start of a new partial payload"),
            TSError::ReaderError(error) => write!(f, "reader error: {}", error),
        }
    }
}

/// TSError equivalence checking only checks to see if the variants are the same and ignores the
/// the stored data.
impl std::cmp::PartialEq for TSError {
    fn eq(&self, other: &Self) -> bool {
        use std::mem::discriminant;
        discriminant(self) == discriminant(other)
    }
}
